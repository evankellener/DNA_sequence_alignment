# -*- coding: utf-8 -*-
"""DNA_Sequence Alignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sOyADnLFb0aVeIrvPcDsULha0AzHinHz
"""

!pip install biopython matplotlib pandas

"""# Example Sequence

>Sequence_1:

ATCGTACGTAGCTAGCTAG
"""

from google.colab import drive
drive.mount('/content/drive')

"""# Convert TEXT file into FAST file

- seqdump.txt was pulled from NCBI
"""

def extract_sequence(file_path):
    with open(file_path, 'r') as file:
        lines = file.readlines()

    # make sure it only containts sequence lines
    sequence = "".join([line.strip() for line in lines if not line.startswith(">")])

    return sequence
# Adjust path
directory_path = #file path
file_path = directory_path+'seqdump.txt'
sequence = extract_sequence(file_path)
print(sequence[:500])

from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio import SeqIO

# convert to FAST format
def save_as_fasta(sequence, output_file):
    record = SeqRecord(Seq(sequence), id="CP023335.1", description="Drosophila melanogaster strain rover (forR)")
    SeqIO.write(record, output_file, "fasta")

save_as_fasta(sequence, directory_path+'sequence_1.fasta')

"""# Develop Sequence Alignement

Alignment is used for comparing sequences of DNA, RNA, or protien structures. It can show similarities which may indicate functional, structural, or evolutionary relationships.

The goal is to align the DNA sequences in a way that maximizes the similarity between two sequences while indentifying possible mutations, insertions, or deletions.

## SNP vs INDLE
- SNP: single nucleotide polymorphisms show up when two nucleotides are different so

    AGCT

    AGGT


 woudl have a SNP at the third position


 - INDEL: Insertion of deletion occurs when there is a gap in the sequence indicating a nucleotide was deleted so

    AGCTC

    AG-TC

woudl have an INDEL at the third position

# Needleman-Wunsch alignment algorithm

An algorithm that uses all posisble alignments and tries to identify the 'best' one by assigning a value to every possible alignemnt and picking the highest score.

## How the score is applied

1. If two Nucleotides mathc you get a +1 score
2. If two Nucleotides don't match you get a -1 score
3. Gap Pently
    - if there a gap(Insertion or Deletion) than you apply a gap pentlty of -5
    - if there is an extended gap after the initial gap there is an extension penalty of -0.5
"""

from Bio import pairwise2
from Bio.pairwise2 import format_alignment

# Two sequences (unaligned)
seq1 = "ACGTGCA"
seq2 = "ACGTTGCGA"


alignments = pairwise2.align.globalms(seq1, seq2, match=1, mismatch=-1, open=-5, extend=-0.5)

#get best alignment
aligned_seq1, aligned_seq2, score, begin, end = alignments[0]

# print aligned sequences
print(f"Aligned Seq1: {aligned_seq1}")
print(f"Aligned Seq2: {aligned_seq2}")

#function to detect mutations (SNPs and INDELs)
def detect_mutations(seq1, seq2):
    mutations = []
    for i, (base1, base2) in enumerate(zip(seq1, seq2)):
        if base1 != base2:  # bases don't match
            mutation_type = 'SNP' if base1 != '-' and base2 != '-' else 'INDEL'
            mutations.append({
                'position': i,
                'seq1_base': base1,
                'seq2_base': base2,
                'mutation_type': mutation_type
            })
    return mutations

# detect mutations
mutations = detect_mutations(aligned_seq1, aligned_seq2)

# Output mutations
for mutation in mutations:
    print(f"Position {mutation['position']}: {mutation['seq1_base']} -> {mutation['seq2_base']} ({mutation['mutation_type']})")

import numpy as np
import matplotlib.pyplot as plt

def plot_combined_visualization_with_aligned_letters_no_whitespace(aligned_seq1, aligned_seq2):
    # Create an alignment matrix based on matches, mismatches, and gaps
    alignment_matrix = np.zeros(len(aligned_seq1))

    for i, (base1, base2) in enumerate(zip(aligned_seq1, aligned_seq2)):
        if base1 == base2:
            alignment_matrix[i] = 1  # Match (green)
        elif base1 == '-' or base2 == '-':
            alignment_matrix[i] = -1  # Gap (blue)
        else:
            alignment_matrix[i] = 0  # Mismatch (red)

    fig, ax = plt.subplots(figsize=(12, 4))

    # Create the heatmap
    cmap = plt.get_cmap('coolwarm')  # Color map for heatmap (coolwarm: blue = gaps, red = mismatches, green = matches)
    heatmap = np.array([alignment_matrix])
    cax = ax.matshow(heatmap, cmap=cmap, aspect='auto', extent=[0, len(aligned_seq1), 0, 1])

    # Add colorbar for reference
    fig.colorbar(cax, ax=ax, orientation='vertical', fraction=0.02, pad=0.04)

    # Set the ticks to be the actual letters of the aligned sequences
    ax.set_xticks(np.arange(len(aligned_seq1)) + 0.5)  # Adjust tick positions to center over each base
    ax.set_xticklabels(aligned_seq1, fontsize=12, ha='center')  # Labels for the top (Seq1)

    # Create another set of labels for Seq2 at the bottom
    ax2 = ax.twiny()
    ax2.set_xticks(np.arange(len(aligned_seq2)) + 0.5)
    ax2.set_xticklabels(aligned_seq2, fontsize=12, ha='center')
    ax2.xaxis.set_ticks_position('bottom')  # Set ticks at the bottom
    ax2.spines['bottom'].set_position(('outward', 40))  # Move bottom ticks outward for better spacing

    # Adjust plot appearance
    ax.set_yticks([])  # Remove y-axis ticks
    ax.set_xlim(0, len(aligned_seq1))  # Ensure the axis is tight to the sequence length
    ax2.set_xlim(0, len(aligned_seq2))  # Ensure the bottom axis aligns with the top
    ax.set_title("Alignment Heatmap: Green = Match, Red = Mismatch, Blue = Gap (INDEL)")

    plt.tight_layout()  # Automatically adjust plot to remove excess space
    plt.show()

# Call the function with aligned sequences
plot_combined_visualization_with_aligned_letters_no_whitespace(aligned_seq1, aligned_seq2)

